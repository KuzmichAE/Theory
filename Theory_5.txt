Задание №5
* Что такое Тест план?
* Что должен описывать тест план?
* Какие вы знаете Виды тест планов?
* Что такое Чек лист?
* Перечислите возможные атрибуты Чек листа
* Перечислите варианты статусов при прохождении Чек листа
* Что такое Тест кейс?
* Перечислите атрибуты Тест кейса?
* Перечислите виды Тест кейсов?
* Что такое Тестовый набор (Test Suite)?
* Что такое Баг репорт?
* Какое нужно соблюдать правило в баг репорте для хорошего Summary?
* Перечислите атрибуты Баг репорта?
* Опишите Жизненный цикл бага
* Что такое Priority?
* Перечислите классификации Priority
* Что такое Severity?
* Перечислите классификации  Severity
* Приведите пример Низкого Priority и Высокого Severity
* Приведите пример Низкого Severity и Высокого Priority
* Что такое Матрица соответствия требований (Requirements Traceability Matrix)?
* Что такое Тест-отчет?
* По времени Тест отчет на сколько типов возможно разделить?
* Что должен показывать Промежуточный отчет?
* Что должен показывать Итоговый отчет?
* Что такое Ошибка/Дефект/Отказ?
* Перечислите Основные типы багов?
* Перечислите “Хитрые баги”?
* Приведите пример Blocker bug
* Приведите пример Critical bug
* Приведите пример Major bug
* Приведите пример Minor bug
* Приведите пример Trivial bug
* Какие основные цели локализации дефекта?
* Где могут находиться дефекты?
* Перечислите методы локализации дефекта в клиентской части
* Перечислите методы локализации дефекта в серверной части







Что такое Тест план?
Тест-план — это артефакт тестирования, который описывает стратегию тестирования, цели, подходы и ресурсы для тестирования ПО. В нем обычно подробно расписывают задачи, которые нужно выполнить, и методы, которые будут использовать. Также указывают ресурсы и сроки этого проекта.
Что должен описывать тест план?
Тест-план отвечает на вопросы:
* что надо тестировать?
* что будете тестировать? 
* как будете тестировать?
* когда будете тестировать? 
* критерии начала и окончания тестирования?


А также раскрывать следующие аспекты:
* Окружение тестируемой системы
* Необходимые для тестирования ресурсы
* Риски и их разрешение


Согласно стандарту IEEE 829, тест план должен состоять из 19 пунктов:
Идентификатор тест плана
Ссылки
1. Введение
2. Объекты тестирования
3. Проблемы и риски
4. Функции, которые нужно протестировать
5. Функции, которые НЕ нужно тестировать
6. Подходы.
7. Критерии прохождения тестов для объектов тестирования
8. Критерии начала тестирования 
9. Критерии окончания тестирования 
10. Критерии остановки и требования для возобновления тестирования
11. Результаты тестирования
12. Оставшиеся задачи тестирования
13. Требования среды
14. Требования по части кадров и их обучения
15. Распределение обязанностей
16. Расписание
17. Планирование рисков и непредвиденных обстоятельств
18. Утверждение
19. Глоссарий


Какие вы знаете Виды тест планов?
Чаще всего на практике приходится сталкиваться со следующими видами тест планов:
1. Мастер тест план (project test plan or Master Test Plan)
2. Тест план (Test Plan), или детальный тест план
3. План приемочных испытаний (Product Acceptance Plan) — документ, описывающий набор действий, связанных с приемочным тестированием (стратегия, дата проведения, ответственные работники и т.д.)
Мастер Тест-План (Master Test Plan): “Главный план тестирования (master test plan, project test plan): План тестирования, обычно охватывающий несколько уровней тестирования.” (ISTQB). Это может быть как единственный базовый план, так и главный в иерархии нескольких планов, самый статичный и высокоуровневый. 
Нужен когда:
* продукт имеет множество релизов или итераций, между которыми сохраняется общая информация, которую нет смысла повторять;
* разные тестовые команды работают над одним продуктом, выполняя различные задачи, которые необходимо объединить в рамках одного документа;


Детальный Тест-план (Phase Test plan): Уровневый план тестирования (level test plan): Детальный план составляется на каждый релиз/итерацию или для каждой команды в рамках проекта и является динамическим, т.е. может претерпевать изменения по необходимости. 
Его основная цель - кратко и доходчиво отразить задачи тестирования. Детальных планов может быть несколько для отдельных модулей ПО или команд тестирования. Кроме того, могут быть созданы планы для отдельных уровней тестирования (Level Test Plan) или видов тестирования. В Agile проектах могут быть планы итерационного тестирования (iteration testing plans) для каждой итерации;


План приемочных испытаний (Acceptance Test Plan, ПСИ): план приемочного тестирования отличают от обычного плана тестирования факторы, которые приводят к принятию бизнес-решения. План приемочного тестирования - это один из жизненно важных документов, который содержит руководство по выполнению приемочного тестирования для конкретного проекта. Пишется на основе бизнес-требований (Business Requirements). Ревью этого плана обычно выполняется by Managers/Business Analysts/Customers.


В повседневной жизни на проекте может быть один мастер тест план и несколько детальных тест планов, описывающих отдельные модули одного приложения.
Что такое Чек лист?
В общем смысле, чек-лист - это набор идей: идей по тестированию, идей по разработке, идей по планированию и управлению — любых идей. Чек-лист в тестировании - это список проверок, которые необходимо провести для тестирования приложения или его части. 


Перечислите возможные атрибуты Чек листа
* Шапка:  содержит информацию о названии приложения, его версии, окружении, на котором проводится тестирование (версия ОС, браузера, эмулятора), ответственного за тестирование, дату тестирования 
* Тестируемые модули, субмодули: например, регистрация, аутентификация авторизация
* Список проверок: они должны отражать основную суть, без лишней детализации
* Статус: информация о статусе прохождения проверки:


Дополнительные части чек-листа
* Ожидаемый результат:  то, что мы ожидаем увидеть после запуска проверки согласно требованиям
* Типы тестирования: к какому типу относится проверка?
* Отчеты о дефекте: ссылки на отчеты о дефектах для прослеживаемости
* Заметки: если нужно добавить комментарии
* Также у проверок может быть уникальный идентификатор для прослеживаемости.
Перечислите варианты статусов при прохождении Чек листа


* Passed (Пройден) — проверка прошла успешно. Используется, когда тест полностью соответствует ожидаемым результатам.
* Failed (Провален) — проверка провалилась. Это значит, что обнаружены несоответствия между фактическим результатом и ожидаемым.
* Blocked (Заблокирован) — тест не может быть выполнен из-за каких-то внешних причин. Например, недостаток данных, сбои в системе или зависимость от другой задачи, которая не завершена.
* Skipped (Пропущен) — тест был намеренно пропущен. Может быть, проверка нерелевантна для текущей версии, задачи или её выполнение не требуется.
* Not Run (Не выполнен) — тест ещё не был выполнен. Этот статус ставится до того, как проверка началась.
* N/A (Not Applicable, не применимо) означает, что проверка или тест не относится к текущему контексту, сценарию или продукту.
Что такое Тест кейс?


Тест-кейс (test case) – это документ, в котором есть: 
* входные данные
* условия выполнения
* ожидаемые результаты,
разработанный с целью проверки того или иного свойства или  поведения программного средства. 
Перечислите атрибуты Тест кейса?
* Идентификатор (ID) - уникальная нумерация тест-кейса в виде сочетания цифр и букв.
* Заголовок. Краткое описание идеи и сути тест-кейса.
* Входные данные.  Указывается информация об исходном состоянии системы.
* Пошаговые мероприятия. Это последовательные пункты, описывающие действия тестировщика.
* Ожидаемый результат. Описание того, что тестировщик ожидает получить по окончании или в процессе тестирования. 
* Фактический результат:  Описание того, что тестировщик получил по факту (если необходимо).
* Статус. Атрибут отражает нынешнее состояние кейса
Перечислите виды Тест кейсов?
1. позитивный тест-кейс проверяет отсутствие сообщений об ошибке там, где это не предусмотрено, и исполнение системой позитивного сценария нормального использования ПО.
2. негативный тест-кейс определяет поведение системы при получении некорректных входных данных. В этом случае система не проигрывает позитивный сценарий, то есть не делает того, что не предусмотрено.
3. деструктивный тест-кейс - проверяет систему на прочность. С его помощью тестировщики изучают сценарии работы ПО в экстремальных условиях, например при повышенной нагрузке, при попытках взломать страницу или внедрить сторонние скрипты в формы регистрации.
Что такое Тестовый набор (Test Suite)?
Тестовый набор - это набор тестов/тест-кейсов, собранных по функциональности в  последовательность для достижения некоторой цели.


Характеристики тестового набора:
* Создается на основе тест-плана
* Описывает цели тест-кейсов
* В тестовый набор входят параметры тестируемого приложения, настройки окружения, и подобные вспомогательные файлы и настройки
* Тестовые наборы могут быть как функциональной, так и нефункциональной направленности
* Тестовые наборы ускоряют и облегчают процесс тестирования
* Тест-кейсы в свите выполняются последовательно, и выполнение следующего зависит от предыдущего
* Могут автоматизироваться, например в Selenium


По предназначению можно выделить следующие типы  тестовых наборов:
* Абстрактный тест-свит, создаваемый при так называемом тестировании на основе моделей. Состоит из группы абстрактных тест-кейсов, созданных на основе высокоуровневой модели приложения
* Выполняемый тест-свит, то есть обычный. Разрабатывается на основе абстрактного и может выполняться (и соответственно автоматизироваться).
Что такое Баг репорт?
Баг-репорт (bug report) — это технический документ, который подробно описывает ошибку в работе программы, приложения или другого ПО. Его составляют, чтобы разработчикам было понятно, что работает неправильно, насколько дефект критичен и что нужно исправить.
Какое нужно соблюдать правило в баг репорте для хорошего Summary?
Как мы уже знаем, Summary (Тайтл, описание) - раздел, который кратко передает суть бага одним предложением. 


Название говорит само за себя - Короткое описание, т.е. в одном предложении нам нужно уместить смысл всего баг репорта, а именно: коротко и ясно, используя правильную терминологию сказать что и где не работает. 


Для этого используется принцип "Где? Что? Когда?"


т.к. в  таком виде незнакомые дефекты удобнее сортировать по summary как показывает практика (ведь, скорее всего, именно среди дефектов других инженеров будет производиться поиск дубликатов).
Перечислите атрибуты Баг репорта?
1. ID -порядковый номер
2. Environment - окружение, на котором найден баг
3. Severity (Серьезность) - атрибут, характеризующий влияние дефекта на работоспособность приложения. Проставляется тестировщиком или техническим специалистом, который может оценить степень влияния дефекта на работу системы
4. Priority (Приоритет) - атрибут, указывающий на очередность выполнения задачи или устранения дефекта. Проставляется руководителем или менеджером проекта
5. Summary (Тайтл, описание) - раздел, который кратко передает суть бага одним предложением.
6. Precondition (Предварительное условие) - используется, если предварительно систему нужно приводить к состоянию, пригодному для проведения проверки
7. Steps (Шаги для воспроизведения) - последовательность действий для воспроизведения бага 
8. Expected result (Ожидаемый результат) - описание того, как программа или функциональность должны работать
9. Actual result (Фактический результат) -  описание того, что происходит на самом деле
10. Attachment (Вложения) - файл с логами, скриншот/видео или любой другой документ, который может помочь прояснить причину ошибки или указать на способ решения проблемы
11. Author (Автор) - создатель баг-репорта
12. Assigned To (Назначен на) - имя сотрудника, назначенного на решение проблемы.
Опишите Жизненный цикл бага
Жизненный цикл бага (bug workflow) – последовательность этапов, которые проходит баг на своем пути с момента его создания до окончательного закрытия.


1. Новый
Первый статус в цикле, New, или Обнаружен, означает, что дефект обнаружен тестировщиком, зарегистрирован, и по нему создан баг-репорт, на основе которого разработчик потом будет искать и устранять дефект.
2.  Назначен
Когда новый дефект подтвержден и принят в обработку разработчиком, получает статус Назначен (Assigned). Как правило назначается ответственный за устранение этого бага (поэтому статус еще может называться «Назначен НА кого-то»). 
3. Решен (Resolved)
На этом этапе,а иногда и ранее мы можем сталкиваться с таким понятием как резолюция
Резолюция – это решение принятое по дефекту. Резолюция – очень важный атрибут, напрямую связанный со статусом, т. е. резолюция – это детализация статуса.
FIXED (Решено) – стандартная резолюция, означающая, что задание выполнено или баг исправлен


Если по мнению разработчика дефект неактуален или некорректен, то по нему могут быть приняты такие резолюции: 
* “Дубликат”(“Duplicate“) - описанная проблема уже зарегистрирована в другом баге.
* “Отложено” (“Deferred”) - eсли разработчику кажется, что у дефекта не очень высокий приоритет, и он может быть исправлен в следующих релизах, то резолюция может быть изменена на ‘Deferred”
* “Отклонено” (“Rejected”) - eсли разработчик считает дефект некорректным, то он помечается как “Rejected”
* “Не ошибка”(“Not a Bug”) - eсли дефект никак не влияет на функциональность приложения, то его резолюция меняется на “Not a Bug”.
       
 Если поставлена резолюция FIXED ,то
4. Ожидает повторного тестирования
В статусе Pending Retest дефект ожидает, когда тестировщики повторно проверят его, убедившись что все ОК, код теперь исправлен.
5. Повторно тестируется
Retest: тестировщик еще раз проверяет этот дефект, и убедившись что он устранен разработчиками, верифицирует это и закрывает дефект, а в противном случае переоткрывает.
6. Повторно открыт
Если повторное тестирование не смогло устранить баг, обнаруживается снова, ему присваивается статус Reopen. Баг открывается опять и еще раз проходит по циклу.
7. Проверен
Тестировщик еще раз проверяет (верифицирует) баг, повторно исправленный разработчиком, и если теперь он не проявляется, присваивается статус Verified.
8. Закрыт
Когда дефект больше не существует и полностью исправлен, тестировщик меняет статус дефекта на “Closed”.
Что такое Priority?


Приоритет — характеристика, которая показывает необходимость скорейшего устранение дефекта. Чем выше приоритет, тем быстрее нужно приступить к работе по исправлению. Это атрибут, указывающий на очередность выполнения задачи или устранения дефекта. Проставляется руководителем или менеджером проекта.
Перечислите классификации Priority
        
* Высокий (High) — такие ошибки нельзя откладывать, они критичны и должны быть исправлены в кратчайшие сроки.
* Средний (Medium) — баги этого уровня не критичны, но требуют обязательного исправления.
* Низкий (Low) — некритичные ошибки, которые не нуждаются в скором решении.
Что такое Severity?


Серьёзность — характеристика, которая показывает влияние бага на работоспособность приложения. Это атрибут, характеризующий влияние дефекта на работоспособность приложения. Проставляется тестировщиком или техническим специалистом, который может оценить степень влияния дефекта на работу системы.
Перечислите классификации  Severity


* Блокирующий (также может называться Blocker или Showstopper) — к нему относятся ошибки, которые останавливают работу приложения или какой-то его части и делают дальнейшее тестирование невозможным.
* Критический (Critical) — этот уровень присваивается падениям, зависаниям, проблемам с безопасностью пользовательских данных, неправильно работающей ключевой бизнес-логике. По сути, это ошибки, решение которых необходимо для дальнейшей работы основных возможностей приложения.
* Значительный (Major) — значительные, но не критичные ошибки, позволяющие далее работать с тестируемыми частями приложения через другие входные точки. К ним относятся, например, неработающие или неправильно работающие функциональности.
* Незначительный (Minor) — небольшие баги, которые не влияют на работу критично, но доставляют неудобства.
* Тривиальный (Trivial) — дефекты, которые не доставляют значительного неудобства: редко встречающиеся баги, косметические, грамматические и орфографические ошибки.
Приведите пример Низкого Priority и Высокого Severity
Такое сочетание бывает у багов, которые возникают в отдельных функциях программы. Эти баги не позволяют пользоваться системой, при этом обойти их невозможно. Но сами функции, содержащие эти дефекты, конечным потребителем используются  редко.


Примеры:


1. Домашняя страница сайта ужасно выглядит в старых браузерах. Перекрывается текст, не загружается логотип. Это мешает пользоваться продуктом, поэтому серьезность бага высокая. Но так как очень мало пользователей открывают сайт при помощи устаревшего браузера, такой баг получает низкий приоритет.
2. Допустим, у нас есть приложение для банкинга. Оно правильно рассчитывает ежедневный, ежемесячный и ежеквартальный отчет, но при расчете годового возникают проблемы. Этот баг имеет высокую степень серьезности. Но если сейчас формирование годовой отчетности не актуально, такой дефект имеет низкий приоритет: его можно исправить в следующем релизе.
3. Редкость проявления дефекта/сложность воспроизведения для юзеров.
4. Невозможность попасть на страницу комментариев к товару — можно отнести к этой области. В этом процессе произошел сбой в свойствах системы; однако, поскольку этот сбой не относится к основному потоку, его целесообразно классифицировать на этом уровне.
Приведите пример Низкого Severity и Высокого Priority
Дефекты с низкой серьезностью, но высоким приоритетом, как правило, связаны с косметическими проблемами или незначительными неудобствами для пользователей, которые, тем не менее, могут повлиять на репутацию продукта или бизнес-процессы компании.


Примеры:


1. Кнопки перекрывают друг друга. Они кликабельны, но визуальное впечатление портится.
2. Логотип компании на главной странице содержит орфографическую ошибку. На функционал это вообще не влияет, но портит пользовательский опыт. Этот баг нужно исправить с высоким приоритетом, несмотря не то, что на продукт он влияет минимально.
Что такое Матрица соответствия требований (Requirements Traceability Matrix)?


Это двумерная таблица, содержащая соответствие функциональных требований (functional requirements) продукта и подготовленных тестовых сценариев (test cases).


Трассируемость (traceability): Способность идентифицировать связанные объекты в документации и программном обеспечении, например, требования со связанными с ними тестами. (ISTQB)


Матрица трассируемости (traceability matrix): Двумерная таблица, описывающая связь двух сущностей (например, требований и тестовых сценариев). Таблица позволяет производить прямую и обратную трассировку от одной сущности к другой, обеспечивая таким образом возможность определения покрытия и оценки влияния предполагаемых изменений. (ISTQB)
Что такое Тест-отчет?
Отчет о тестировании (Test report) – вид тестовой документации, который обобщает опыт проведенных QA-мероприятий. Он может быть разных типов, от этого зависит его содержание. Отчет о тестировании служит для принятия соответствующих решений в IT-проекте.


Отчет (Report) - это документ, содержащий информацию о выполненных действиях, результатах проведённой работы. Обычно он включает в себя таблицы, графики, списки, просто описывающую информацию в виде текста. Их пропорция и содержание определяют пользу и понятность отчета.


Нам важно понять, для кого, для чего и в каких условиях мы это делаем и на сколько это улучшит восприятие излагаемой нами информации.
По времени Тест отчет на сколько типов возможно разделить?
Отчеты по тестированию программного обеспечения классифицируют по времени:
1. Недельный, месячный, промежуточный. В подобных отчетах тестировщик указывает две основные метрики: уровень готовности, оценку проведенного тестирования; В общем, это практически тот же финальный отчет, но с измененными приоритетами фокуса и уменьшенной глубиной временной выборки. 
2. Версионный. Похож на финальный отчет. Здесь указывают, какие задачи выполнялись командой, работающей над проектом. Делается в конце работы над каждой версией приложения;
3. Финальный, или заключительный. Прописывается эволюция продукта, описывается общий взгляд на сделанную работу. Также, надо дать исчерпывающую информацию о статусе продукта в данный момент (количество оставшихся неисправленных ошибок, полностью ли протестирован продукт или требуется дополнительный цикл тестирования, оценка возможности выпуска продукта во «внешний мир» и т.д).
Что должен показывать Промежуточный отчет?


Промежуточный отчет составляется и отправляется на всех заинтересованных лиц после проведения каждого вида тестов. Данный тип отчета составляет инженер по тестированию, проверивший заданную часть функциональности. 


Что должен показывать Итоговый отчет?


В конце предопределенного промежутка времени (обычно за неделю либо перед выходом очередной сборки) составляется итоговый отчет о всей проделанной работе. В отчете отражена информация о качестве всех проведенных видов тестов. Как правило, такой отчёт составляет ведущий тестировщик либо руководитель QA-команды. Он анализирует всю информацию о состоянии ПО и собирает её воедино.
Что такое Ошибка/Дефект/Отказ?


Ошибка (ISTQB) — любое действие человека, которое вызвало неверный результат. Ошибки могут быть допущены разработчиками, тестировщиками или пользователями.


Дефект (баг) — изъян в компоненте или системе, который может привести компонент или систему к невозможности выполнить требуемую функцию (ISTQB). Это несоответствие между ожидаемым результатом и фактическим поведением системы. 


Отказ (ISTQB) – событие, при котором система не выполняет ожидаемую функцию. Это постоянное нарушение работы системы, которое делает её непригодной для использования. Отказы могут быть вызваны серьезными дефектами или ошибками, которые не были обнаружены и исправлены.
Перечислите Основные типы багов?
1. Воспроизводимый — баг, который может быть воспроизведен тестировщиком в тестовом окружении.
2. Невоспроизводимый — баг, который не может быть воспроизведен тестировщиком в тестовом окружении.
3. Фатальный — баг, который вызывает крах или аварийное завершение программы.
4. Не фатальный — баг, который не вызывает крах программы, но может приводить к некорректному поведению или неправильным результатам.
5. Функциональный  — баг, связанный с неправильной работой функциональности программы.
6. Нефункциональный — баг, связанный с аспектами производительности, надежности, безопасности и т.д. программы.
7. Интерфейсный — баг, связанный с интерфейсом пользователя.
8. Синтаксический — баг, связанный с нарушением правил синтаксиса языка программирования.
9. Логический — баг, связанный с неправильной логикой работы программы.
10. Спецификационный — баг, связанный с нарушением требований к программе, указанных в спецификации.
11. Визуальный — баг, связанный с отображением графических элементов программы.
12. Локализационный — баг, связанный с неправильным отображением или переводом программы на другие языки.
13. Неоднозначный — баг, который может иметь несколько причин и неоднозначный результат.
14. Потенциальный — баг, который еще не проявился, но может возникнуть в будущем при определенных условиях.
15. Дублирующий — баг, который уже был зарегистрирован и описан ранее.
Перечислите “Хитрые баги”?
Хитрые баги — это скрытые дефекты, которые трудно обнаружить из-за специфических условий их возникновения. Они могут проявляться нерегулярно, в зависимости от конфигурации системы, загрузки или временных факторов.


* Гейзенбаг — это баг, который исчезает или меняет свое поведение, как только его пытаются изучить или отладить.
* Борбаг — это баг, который проявляется постоянно, но только при определенных условиях или входных данных.
* Мандельбаг — это баг с чрезвычайно сложным и непредсказуемым поведением, часто вызванный глубокими архитектурными дефектами системы.
* Шрединбаг — это баг, который проявляется только при определённых условиях и может исчезнуть при попытке изучения кода. Как и в парадоксе Шрёдингера, баг как бы «существует и не существует одновременно», пока его не начнут тестировать.
* Лунный баг — это баг, который проявляется только в определённое время, зависимо от даты или времени суток. Он может возникнуть из-за скрытых временных параметров в коде, что делает его сложным для обнаружения и воспроизведения.
* Статистический баг — это баг, который не проявляется при одном прогоне, но возникает при многократном выполнении кода, генерирующего случайные или псевдослучайные результаты.
* Гинденбаг — это баг, который может привести к катастрофическим последствиям для системы, особенно в критически важных инфраструктурах или колоссальным  финансовым убыткам.
* Баг Хиггса — это баг, существование которого предсказано или предполагается, но на практике его невозможно обнаружить. Он может существовать только «теоретически», из-за ошибки в логике кода, но никогда не проявляется при реальном использовании.
Приведите пример Blocker bug
S4 Blocker (Блокирующий) — ситуация, когда программа не работает в принципе: сайт выдает «ошибку 404» или не запускается приложение.
Приведите пример Critical bug
S3 Critical (Критический) — баг мешает приложению выполнять основные функции: калькулятор расходов неправильно считает бюджет или в текстовом редакторе невозможно вводить текст.
Приведите пример Major bug
S2 Major (Серьезный) — баг создает неудобства в использовании, но еще не нарушает функционал программы.
Приведите пример Minor bug
S1 Minor (Незначительный) — баг почти не нарушает логику процессов, поэтому с ним программа может нормально работать. Например, неудобная навигация в интерфейсе.
Приведите пример Trivial bug
S0 Trivial (Тривиальный) — баг не влияет на работу программы, поэтому для его исправления могут не выделить отдельную задачу, а исправить попутно при исправлении других, похожих ошибок. Например, при заполнении анкеты в поле «Дата рождения» по умолчанию отображается не актуальный год, а 1999-й.
Какие основные цели локализации дефекта
1. **Выявление и диагностика проблемы**: Локализация дефекта помогает выявить конкретные ошибки или сбои в коде, что упрощает их дальнейшее устранение.


2. **Повышение эффективности отладки**: Чем точнее мы локализуем дефект, тем быстрее и легче программисты могут его устранить. Это снижает время, затраченное на поиск проблемы в исходном коде.


3. **Снижение рисков**: Локализация помогает минимизировать риски, связанные с внедрением новых функций или изменениями в коде, которые могут вызвать новые дефекты.


4. **Обеспечение качества**: Быстрая и точная локализация дефектов способствует повышению общего качества продукта, так как помогает выявить и исправить ошибки до выхода ПО в продакшн.


5. **Оптимизация процесса тестирования**: Локализация дефектов позволяет тестировщикам более эффективно планировать свои тесты и фокусироваться на участках кода, которые требуют дополнительного внимания.


6. **Сбор информации о дефектах**: Локализация позволяет собирать данные о типах и частоте дефектов, что в свою очередь помогает в анализе и дальнейшем улучшении разработки.


7. **Улучшение взаимодействия с командой**: Четкое понимание и документирование локализованных дефектов способствует лучшему взаимодействию между тестировщиками и разработчиками, что ускоряет процесс исправления.


8. **Повышение удовлетворенности пользователей**: Быстрая локализация и исправление дефектов ведет к созданию более стабильного и надежного ПО, что в свою очередь улучшает опыт конечных пользователей.
Где могут находиться дефекты?
1. **Код (исходный код)**: Ошибки в логике, синтаксисе, неправильные алгоритмы, проблемы с управлением памятью и другие ошибки программирования.


2. **Интерфейс пользователя (UI)**: Неправильное отображение элементов, проблемы с взаимодействием, непродуманный пользовательский опыт, неработающие кнопки и ссылки.


3. **Back-end и серверная часть**: Ошибки в API, проблемы с базами данных, неправильно реализованная бизнес-логика, некорректная обработка запросов и ответов.


4. **Базы данных**: Неправильные запросы, проблемы с индексацией, ошибки в схеме базы данных, ненадежные транзакции.


5. **Интеграция с внешними системами**: Проблемы при взаимодействии с другими сервисами или API, ошибки в обмене данными.


6. **Настройки конфигурации**: Неправильные конфигурационные файлы, недостающие параметры, ошибки в окружении, которые могут привести к сбоям или неправильному поведению.


7. **Производительность и нагрузки**: Проблемы с производительностью, возникающие под нагрузкой, такие как сбои, задержки или утечки памяти, могут проявляться только при высоких объемах трафика.


8. **Безопасность**: Уязвимости в приложении, которые могут быть использованы для несанкционированного доступа, потери данных или других атак.


9. **Система и окружение**: Проблемы с совместимостью на разных операционных системах или устройствах, зависимости от сторонних библиотек и платформ.


10. **Процессы и требования**: Неправильная реализация функциональных требований, недоразумения между командами (разработчиками, тестировщиками и бизнес-аналитиками).


11. **Документация**: Неполная или неактуальная документация может привести к неправильному использованию ПО и, следовательно, к возникновению дефектов.


Перечислите методы локализации дефекта в клиентской части
* Инспектирование DOM — визуальный анализ структуры страницы через инспектор в браузере для поиска проблем с версткой, CSS и взаимодействиями элементов.
* Логи браузера/консоль разработчика — проверка ошибок и предупреждений в консоли разработчика в браузере (F12). Это помогает выявить JavaScript ошибки, сетевые запросы, проблемы с загрузкой ресурсов и другие ошибки.
* Отладка (debugging) — этап разработки компьютерной программы, на котором обнаруживают, локализуют и устраняют ошибки.
* Инструменты сетевого мониторинга — использование вкладки "Сеть" (Network) в консоли разработчика браузера для анализа сетевых запросов, ответа сервера, заголовков и статусов HTTP.
* Анализ производительности (Performance) — изучение вкладки "Performance" для выявления проблем с производительностью клиентской части, таких как долгие загрузки или утечки памяти.
* Перезапуск с кешем и без кеша — очистка кеша и повторная загрузка страницы для исключения проблем, связанных с кешированием
* Эмуляция/симуляция мобильных устройств — использование инструментов эмуляции и симуляции для проверки отображения и работы на разных на мобильных устройствах.
* Fiddler/Charles Proxy — для перехвата и анализа сетевых запросов, когда нужно глубже проанализировать обмен данными между клиентом и сервером.


Перечислите методы локализации дефекта в серверной части


* Анализ HTTP-ответов — проверка статусов HTTP-ответов, содержимого тела ответа и заголовков с помощью инструментов браузера или сетевых утилит. Это позволяет понять, есть ли ошибки со стороны сервера (например, 500 Internal Server Error).
* Postman — использование инструментов для отправки API-запросов напрямую к серверу для проверки корректности обработки запросов и ответов без участия клиентской части.
* Логи сервера — просмотр серверных логов, чтобы выявить ошибки или исключения, возникающие на сервере при выполнении запросов.
* Мониторинг серверных ресурсов — анализ нагрузки на сервер, доступности ресурсов (CPU, память, диск) с помощью мониторинговых систем, чтобы понять, не является ли дефект следствием нехватки ресурсов.
* Дебаг на стороне сервера — совместная работа с разработчиками для использования отладочных инструментов сервера (например, отладка с помощью IDE или других инструментов логирования).
* Анализ базы данных — проверка запросов к базе данных на правильность, выполнение и результаты с помощью инструментов мониторинга БД (например, SQL-запросы, используемые сервером).
* Тестирование кэширования — проверка корректности работы серверного кэширования, например, как сервер обрабатывает повторяющиеся запросы и обновляет данные.
* Redis и Memcached — для серверного кэширования часто используются Redis и Memcached. Их нужно тестировать на корректную работу в плане производительности и хранения данных.
* Varnish Cache — может быть использован для кэширования HTTP-ответов, что особенно полезно для веб-приложений с высокой нагрузкой.