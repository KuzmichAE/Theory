Задание №4
* Что такое Тест дизайн?
* Для чего нужны Техники тест дизайна?
* Какие знаете техники черного ящика?/Опишите их.
* Какие знаете техники белого ящика?/Опишите их
*  (Migration testing)/Тестирование после миграции (Post-Migration testing)?










Что такое Тест дизайн? 


Тест дизайн - это один из первоначальных этапов тестирования программного обеспечения, этап планирования и проектирования тестов. Тест дизайн представляет собой продумывание и написание тестовых случаев (test case), в соответствии с требованиями проекта, критериями качества будущего  продукта и финальными целями тестирования.


Техники тест-дизайна - это рекомендации, советы и правила, по которым стоит разрабатывать тест для проведения тестирования приложения. Это не образцы тестов, а только рекомендации к применению. В частности различные инженеры могут работая под одним и тем же проектом создать различный набор тестов. Правильным будет считаться тот набор тестов, который за меньшее количество проверок обеспечит более полное покрытие тестами. 


* Эквивалентное разделение (Equivalence Partitioning - EP).
* Анализ граничных значений (Boundary Value Analysis - BVA).
* Предугадывание ошибки (Error Guessing - EG).
* Исчерпывающее тестирование (Exhaustive Testing - ET).
* Причина/Следствие (Cause/Effect-CE)
* Таблица принятия решений (Decision table).
* Тестирование состояний и переходов (State - transition testing).
* Метод парного тестирования (Pairwise testing)
Для чего нужны Техники тест дизайна?


Цели тест-дизайнов
* Придумать тесты, которые обнаружат наиболее серьезные ошибки продукта. Да, мы можем придумывать тесты, которые находят несерьезные ошибки, но тогда тестирование будет неэффективным.
* Минимизировать количество тестов, необходимых для нахождения большинства серьезных ошибок. Мы может придумать столько тестов, сколько не в состоянии будем выполнить. Поэтому перед разработчиками тестов всегда стоит задача – сохранить эффективность тестов (то есть их способность обнаруживать серьезные ошибки) без увеличения их числа.


Задачи тест-дизайна: 
* Проанализировать требования к продукту
* Оценить риски возможные при использовании продукта
* Написать достаточное минимальное количество тестов
* Разграничить тесты на приемочные, критические, расширенные




Какие знаете техники черного ящика?/Опишите их.
Эквивалентное разделение (Equivalence Partitioning - EP).


Эквивалентное разбиение - тестирование методом черного ящика, в котором тестовые условия представлены эквивалентными областями, проверяемыми на одном представителе каждой области.
Суть техники эквивалентного разбиения в том, чтобы:
* Разделить данные на группы (классы эквивалентности), которые, как предполагается, обрабатываются системой схожим образом (то есть ведут систему к одному состоянию);
* Из каждой группы (класса) выбрать одно значение и проверить его.


Класс эквивалентности (Equivalence class) – это набор входных (или выходных) данных, которые обрабатываются программой по одному алгоритму или приводят к одному результату.
Классы эквивалентности могут быть:
1. Линейные - упорядоченное множество на числовой прямой (цифры)
Нелинейные - неупорядоченное множество данных, не имеющих граничных значений (буквы, спецсимволы, валюта и др)
2. Валидные - допустимые значения исходя из требований, позитивные тесты
Невалидные - недопустимые значения, негативные тесты


Что можно разбить на классы эквивалентности
* Числа
* Символы (они могут быть валидными, например, использование @ в адресе электронной почты, и невалидными — ?, %, *;)
* Длину строки (например, валидный класс от 1 до 50 знаков, невалидный — всё остальное, то есть меньше 1 и больше 50)
* Размер файла (если мощности сервера не позволяют обработать объем данных больше определённого значения.)
* Объем памяти (необходимый приложению для стабильной работы)
* Расширения экрана (всё, что меньше или больше заявленных требований к разрешению экрана, будет относиться к невалидным классам)
* Версии ОС, библиотек (также определяются согласно требованиям. Например, приложение должно работать на ОС Windows 7, но поддержка Windows NT уже не требуется)


Несколько простых правил.
1. Если область определения параметра — диапазон, то имеет смысл выделение трех классов эквивалентности: слева от диапазона (невалидные значения), сам диапазон (валидные значения) и справа от диапазона (снова невалидные). При выделении классов нужно использовать включающие границы с целью однозначности и точности: одно и то же значение не может относиться к двум классам одновременно.
2. Если область определения — набор неупорядоченных данных, то всегда можно выделить как минимум два класса — валидные и невалидные значения. Полученное разбиение можно «дробить» дальше. Например, множество латинских букв можно разбить на два подмножества: латиница в верхнем и нижнем регистре соответственно.
Пошаговый процесс эквивалентного разбиения:
1. Определить классы эквивалентности. Это главный шаг техники. От него во многом  зависит эффективность её применения.
2. Затем нужно выбрать одного представителя от каждого класса. На этом шаге из каждого эквивалентного набора тестов мы выбираем один тест.
3. Нужно выполнить тесты. На этом шаге мы выполняем тесты от каждого класса эквивалентности.
Анализ граничных значений (Boundary Value Analysis - BVA).


Граничные значения — это те места, в которых один класс эквивалентности переходит в другой. Цель этой техники — найти ошибки, связанные с граничными значениями. На каждой границе диапазона следует проверить по три значения:
1. граничное значение;
2. значение перед границей;
3. значение после границы.
Алгоритм использования техники граничных значений:
* выделить классы эквивалентности;
Все классы эквивалентности делятся на три типа:


* Класс, который имеет нижнюю и верхнюю границы 
* Класс, который имеет только нижнюю границу 
* Класс, который имеет только верхнюю границу 
Этот шаг является очень важным и от того, насколько правильным будет разбиение на классы эквивалентности, зависит эффективность тестов граничных значений.
* определить граничные значения этих классов;
* нужно понять, к какому классу будет относиться каждая граница;
* нужно провести тесты по проверке значения до границы, на границе и сразу после границы.
Методы анализа граничных значений


* При анализе граничных значения методом 2 BVA мы берем одно значение внутри класса и одно ближайшее значение вне класса.
* При анализе граничных значения методом 3 BVA мы берем два значение внутри класса и одно ближайшее значение вне класса.


Тестирование состояний и переходов (State - transition testing).


Тестирование состояний и переходов изучает, как система переходит из одного состояния в другое в ответ на события.
Состояния — это различные условия (или режимы), в которых может находиться система. Определенные события вызывают («триггерят») переходы, т.е.  перемещения между этими состояниями.
Схематически подобную методику отображают в форме кругов(прямоугольников) и стрелочек, где:
1. Кружочки, прямоугольники — это текущее состояние объекта;
2. Стрелочки — ситуация, событие или процесс, благодаря которым объект может двигаться из стадии А в стадию В. Это своего рода действие, которое может выполнятся как пользователем, так и системой.
  

Таким образом, диаграммы состояний и переходов помогают нам выявлять потенциальные дефекты, проверять правильность переходов между состояниями, и гарантировать, что программное обеспечение работает так, как задумано его создателями, и соответствует требованиям.
Использование подобных схем позволяет наглядным образом визуально оценивать, какие переходы может выполнить ПО и что нужно протестировать в первую очередь.


Диаграммы переходов состояний служат основой для разработки тест-кейсов и изучения поведения нашего программного обеспечения. Стрелочки в данном случае — это уже сформированные тест-кейсы, которые и нужно проверять! А состояние к которому приводит переход  - это ожидаемый результат!
Тестирование по сценариям использования (Use case)


Что такое тестирование по сценариям использования? — это подход, при котором система тестируется на основе реальных пользовательских сценариев, которые описывают, как люди взаимодействуют с программой. Тестировщики создают пошаговые инструкции для сценариев, начиная с момента входа в систему до выполнения конкретной задачи.


Основная цель — убедиться, что каждая функциональная часть программы работает так, как ожидается в реальных условиях. Тестирование по сценариям помогает обнаружить проблемы, которые могут возникнуть в процессе обычного использования, а не только в отдельных функциональных тестах.


Пример сценария использования — например, пользователь хочет купить товар в интернет-магазине. Сценарий может включать поиск товара, добавление его в корзину, ввод информации для оплаты, подтверждение заказа, получение подтверждения на email. Этот сценарий тестируется от начала до конца.


Ключевые компоненты сценария использования


Актор (пользователь)
Это либо человек (конечный пользователь), либо система, которая взаимодействует с программным обеспечением. Важно учитывать разные типы пользователей — например, новый пользователь, опытный пользователь, администратор системы и т.д.
Система
Это программное обеспечение или приложение, которое тестируется. Система должна корректно обрабатывать запросы и действия пользователя на каждом этапе сценария.
Шаги (последовательность действий)
Сценарий использования состоит из шагов, которые пользователь предпринимает для достижения своей цели. Например:
1. Вход в систему.
2. Поиск товара.
3. Добавление товара в корзину.
4. Оплата.
5. Получение подтверждения.
Ожидаемый результат
Для каждого шага тестировщик определяет, что должно произойти. Например, при добавлении товара в корзину пользователь должен увидеть сообщение о том, что товар успешно добавлен.


Тестирование таблицы решений (Decision table testing)


Тестирование таблицы решений — это метод тестирования программного обеспечения, используемый для проверки поведения системы при различных комбинациях входных данных. Это систематический подход, при котором различные входные комбинации и соответствующее им поведение системы (Выход) фиксируются в табличной форме. Именно поэтому его еще называют Причина-Следствие таблица, в которой указаны причины и следствия для лучшего охвата тестами.


Цель тестирования по этой методике — повысить общее тестовое покрытие, не упуская все (возможные) комбинации.


Таблица решений представляет собой табличное представление входных данных в сравнении с правилами/случаями/условиями тестирования. Это очень эффективный инструмент. Таблица решений помогает проверить все возможные комбинации условий для тестирования, а тестировщики также могут легко выявить пропущенные условия. Условия обозначаются значениями True(T) и False(F).


Какие компоненты входят в таблицу решений?
Таблица решений — это двухмерная матрица, в которой есть четыре компонента: Заголовок условия (condition stub), Заголовок действия (action stub), Условие (condition entry), и Действие (action entry).
Более простыми словами, таблица решений состоит из условий (в заголовках строк и колонок), и действий (в точках пересечения условий). 


Существует несколько видов таблиц принятия решений:
Таблицы с ограниченным вводом — условия в этой категории ограничены. Например, «Истина» или «Ложь».
Таблицы с расширенным вводом — условия могут иметь более двух значений, кроме «Истина» или «Ложь».
Причина/Следствие (Cause/Effect-CE)


Этот метод используется в тестировании для определения комбинаций условий (причин), которые могут привести к определенному результату (следствию) в системе. 


Проще говоря, это простая проверка базовых действий и их результата. Например, если нажать крестик в правом верхнем углу окна (причина), оно закроется (следствие), и т.д. Этот метод позволяет проверить все возможности системы, а также обнаружить баги и улучшить техническую документацию продукта.


Примерный алгоритм использования техники: 
1. Выделяем причины и следствия в спецификациях.  
2. Связываем причины и следствия.  
3. Учитываем «невозможные» сочетания причин и следствий.  
4. Составляем «таблицу решений», где в каждом столбце указана комбинация входов и выходов, т.е. каждый столбец – это готовый тестовый сценарий.  
5. Расставляем приоритеты.


Эта техника помогает: 
* Определить минимальное количество тестов для нахождения максимума ошибок. 
* Выяснить все причины и следствия – таким образом, мы убедимся, что на любые манипуляции с системой у системы будет ответ. 
* Найти возможные недочеты в логике описания приложения (что, в свою очередь, поможет улучшить документацию).
Исчерпывающее тестирование (Exhaustive Testing - ET).
— это метод тестирования, при котором проверяются все возможные комбинации входных данных и сценариев использования приложения. 


Пример задачи для исчерпывающего тестирования
Представим, что у нас есть простое приложение для ввода пароля. Допустим, пароль может состоять из 12 символов, и каждый символ может быть одной из 6 возможных букв (например, A, B, C, D, E, F). В этом случае количество возможных комбинаций пароля будет равно (6^{12}) (шесть в двенадцатой степени), что составляет 2,176,782,336 комбинаций1.Преимущества исчерпывающего тестирования
Исчерпывающее тестирование имеет следующие преимущества:
* Тесты могут быть автоматизированы, что избавит от необходимости проводить работу вручную.
* Проверяет все возможные варианты данных в наборе.
* Делает программу более надежной, выявляя любые возможные ошибки.
* Выполняет повторное тестирование задач с высоким приоритетом.
* Повышает удовлетворенность клиентов от продукта.


Задача: Проверить все возможные комбинации пароля для обеспечения его надежности. Шаги:
* Генерация всех возможных комбинаций: Создать скрипт или программу, которая сгенерирует все возможные комбинации пароля.
* Проверка каждой комбинации: Для каждой сгенерированной комбинации выполнить проверку, например, попытаться войти в систему с этим паролем.
* Анализ результатов: Записать результаты каждой попытки и проанализировать их на наличие ошибок или уязвимостей.
Сценарий: Проверка формы поиска рецептов.
* Ввод данных: Ввести различные комбинации ингредиентов в поле поиска (например, “конина” , “первые или вторые блюда”).
* Ожидаемый результат: Сайт должен корректно отображать рецепты, соответствующие введенным ингредиентам.
* Проверка: Убедиться, что результаты поиска соответствуют ожиданиям и нет ошибок.
Комбинаторные техники (попарное, базовый выбор, каждого выбора, ортогональные матрицы)
* Попарное (Pairwise) тестирование
ISTQB определяет попарное тестирование как технику тест-дизайна методом черного ящика, при которой тест-кейсы создаются таким образом, чтобы выполнить все возможные отдельные комбинации каждой пары входных параметров.
Применяя попарное тестирование, мы упрощаем процесс тестирования и уменьшаем количество тестовых сценариев, что обеспечивает быстрое тестирование без значительного влияния на качество. 
Метод попарного тестирования базируется на гипотезе, что подавляющее большинство дефектов ПО возникает, когда взаимодействуют два входных параметра. Следовательно, надо проверить не все возможные комбинации параметров, а только такой набор комбинаций, в котором каждая пара параметров встретится хотя бы раз. Таким образом, техника попарного тестирования позволяет значительно сэкономить на количестве тестов.


Процесс попарного тестирования может выглядеть так:
* Определение всех параметров, которые нужно протестировать.
* Создание матрицы сочетаний, где каждая строка представляет собой уникальную комбинацию параметров.
* Выбор минимального набора тест-кейсов, который покрывает все возможные пары параметров.
* Проведение тестирования согласно выбранному набору тест-кейсов.


* Базовый выбор 
Техника базового выбора (Base Choice) — одна из комбинаторных техник тест-дизайна, которая ориентирована на выбор базового набора тестовых значений для каждой переменной, а затем создание тестовых случаев путем изменения только одной переменной за раз, оставляя остальные на базовом уровне.


Основные шаги:
* Определение базового набора значений: Для каждой входной переменной выбирается "базовое" значение. Это значение обычно выбирается как наиболее типичное или наименее рискованное.
* Создание тестового случая для базового набора: Создается один тестовый случай, который использует базовые значения для всех входных переменных.
* Варьирование значений: Для каждой входной переменной создается отдельный тестовый случай, в котором эта переменная принимает одно из своих альтернативных значений, в то время как все остальные переменные остаются на базовом уровне.


* Каждый выбор 
эта стратегия требует, чтобы каждое значение каждого параметра было включено по крайней мере в один тестовый пример (Ammann & Offutt, 1994). Это также определение 1-wise coverage.
Пример - в магазине бытовой техники планируют продавать товары следующих категорий: холодильники, морозильные камеры стиральные и сушильные машины. Доступны следующие бренды: Haier, Lg, Bosch, Hotpoint, Indesit, Leran и Atlant. Также существует возможность выбора способа доставки: самовывоз, доставка.
Согласно тексту задания, можно выделить следующие параметры:
Категория
	Брэнд
	Способ получения
	Холодильник
	Haier
	Самовывоз
	Морозильная камера
	Lg
	Доставка
	Стиральная машина
	Bosch
	 
	Сушильная машина
	Hotpoint
	 
	 
	Indesit
	 
	 
	Leran
	 
	 
	Atlant
	 
	Если выполнять проверку всех возможных комбинаций, то получаем 4*7*2=56 проверок.
Применим технику каждого выбора. Эта техника означает, что каждое значение каждого конкретного параметра должно быть использовано по крайней мере один раз в тестовом наборе. Таким образом, результирующее количество случаев будет равно количеству значений параметра с наибольшим диапазоном. Каждый выбор представляет собой технику минимального покрытия. Получаем 7 проверок.
Проверка
	Категория
	Брэнд
	Способ получения
	1
	Холодильник
	Haier
	Самовывоз
	2
	Морозильная камера
	Lg
	Доставка
	3
	Стиральная машина
	Bosch
	Самовывоз
	4
	Сушильная машина
	Hotpoint
	Доставка
	5
	Холодильник
	Indesit
	Самовывоз
	6
	Морозильная камера
	Leran
	Доставка
	7
	Стиральная машина
	Atlant
	Самовывоз
	

* Ортогональные матрицы
Ортогональный массив (ортогональная таблица) - это таблица, обладающая следующими свойствами:
* Любые два столбца таблицы содержат все комбинации значений этих столбцов.
* Если какая-либо пара значений двух столбцов встречается несколько раз, то все возможные парные комбинации значений этих столбцов должны встретиться столько же раз.
Т.е. в отличие от механизма all pairs, в основе которого лежит фокус на том, чтобы каждая возможная пара значений для двух параметров была проверена хотя бы один раз, ортогональные массивы обеспечивают более равномерное и полное покрытие. Количество тестов может быть больше, чем в попарном тестировании, но все равно значительно меньше, чем при полном переборе всех возможных комбинаций. 


Названия ортогональных таблиц записываются в виде следующей формулы:
  

  



Существуют так называемые смешанные (mixed) ортогональные массивы, где столбцы могут принимать разное количество значений. Например, L18(2137) – смешанный ортогональный массив с восемнадцатью строками, у которого один столбец со значениями 1 и 2, и семь столбцов со значениями 1, 2, 3.


Для тестирования с использованием ортогональных массивов выполняют следующие шаги:
1. Определяют переменные для входных данных в комбинациях. Например, это могут быть названия опций, параметров настроек, допустимых конфигураций оборудования и т. п.
2. Определяют значения, которые могут принимать переменные. Например, конкретные названия пунктов меню, числовые значения, названия операционных систем или баз данных и т. п.
3. Строят ортогональный массив, который имеет столбец для каждой переменной. Каким образом это можно сделать?
* руками
* используя библиотеки готовых ортогональных таблиц. Например, нам нужен массив 816133. К сожалению, такого ортогонального массива не существует. Но существует ортогональный массив 8243, который нам подходит, т.к. можно заменить колонки 81 и 61 на 82, а 33 - на 43. 


Какие знаете техники белого ящика?/Опишите их
Покрытие операторов


100% покрытие операторов (Statement/node coverage). Оператор (statement) - это сущность языка программирования, обычно являющаяся минимальным неделимым исполняемым блоком (ISTQB). Покрытие операторов - это метод проектирования тестов методом белого ящика, который включает в себя выполнение всех исполняемых операторов (if, for и switch) в исходном коде как минимум один раз. Процентное отношение операторов, исполняемых набором тестов, к их общему количеству является метрикой покрытия операторов. Борис Бейзер написал: "тестирование, меньшее чем это (100% покрытие операторов), для нового программного обеспечения является недобросовестным и должно быть признано преступлением. …”. Несмотря на то, что это может показаться разумной идеей, на таком уровне покрытия может быть пропущено много дефектов и затруднен анализ покрытия некоторых управляющих структур. Покрытие операторов позволяет найти:


* Неиспользованные выражения (Unused Statements);
* Мертвый код (Dead Code);
* Неиспользуемые ветви (Unused Branches);
* Недостающие операторы (Missing Statements);


Покрытие решений, альтернатив


Покрытие решений (Decision Coverage) — это метод тестирования программ, который проверяет, чтобы каждая возможная ветвь решения в коде была выполнена хотя бы один раз.


Как проводятся тесты покрытия решений?
Каждая строка программы должна пройти через тестирование покрытия решений, чтобы найти любые потенциальные потоки принятия решений в кодах. Хорошо известно, что этот этап тестирования кода имеет решающее значение для процесса создания программ и разработки приложений. Пропуск этого этапа может серьезно снизить эффективность программы в этом модуле.
 
Сквозное выполнение программы сканируется на начальном этапе тестирования покрытия решений, чтобы найти указания решений, разбросанные по всему коду. Здесь решения — это не что иное, как код, который имеет более одного возможного результата, может иметь более одного пути выполнения и в конечном итоге может привести к производству одного или нескольких продуктов.
Следующие этапы подразумевают составление логической схемы принятия решений и перечисление результатов многочисленных выборов, сделанных и включенных в код приложения.
Оценка индикаторов логического решения, собранных и созданных в предыдущих частях этого процесса тестирования, является последним и самым важным шагом в процедуре тестирования покрытия решений. Различные логические конечные точки проходят необходимые процедуры проверки и верификации. Если полученный конечный результат согласуется с предполагаемым результатом - процесс тестирования считается успешным.


Покрытие условий 


Тестирование покрытия условий — это тип тестирования «белого ящика», который проверяет все условные выражения в программе для всех возможных результатов условий. Его также называют покрытием предикатов .
Оно гарантирует, что тестирование включает выполнение обеих ветвей в решении, как оператор if. Если точка принятия решения имеет разные условия (используя AND или OR), покрытие условий гарантирует, что мы протестировали все различные комбинации условий.
 
Как работает покрытие условий?
1.        Определение точек принятия решений : первым шагом является определение точек принятия решений в коде, обычно представленных условными операторами, такими как if, else if, и else.
2.        Анализ условий : Каждая точка принятия решения может содержать несколько условий, которые оцениваются для определения пути выполнения. Важно проанализировать эти условия и разбить их на более простые компоненты, чтобы обеспечить комплексное тестирование.
3.        Создание тестовых случаев : Тестовые случаи создаются для покрытия обоих возможных результатов каждого условия – true и false. Это гарантирует, что все ветви кода будут проверены во время тестирования.
4.        Выполнение тестов и генерация отчетов : выполняется тестовый набор и генерируется отчет о покрытии для оценки степени достигнутого покрытия условий. Отчет выделяет протестированные и непроверенные условия, что облегчает дальнейшее уточнение тестовых случаев.